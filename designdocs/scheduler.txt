The scheduler

The scheduler is responsible for getting harvesting requests from Jakub's 
web service, and creating a number of harvesting threads (using Marc's 
harvesting classes) to do the actual work.



Simple pseudocode:

  - Poll list of jobs
  - For each job, see if it is already running. If not
      - check if it is time to run it now. If not, move on to the next.
      - if we don't have too many threads running already
         - create a harvester with the job parameters
         - create a thread that will run the job
  - For each job that has gone missing from the list
      - if there is a thread running, send it a signal to close down
      - remove from the list when it reports done or error
  - Poll active threads for some status information, and pass it to the ws.
  - When a thread is done, get its status information and pass it to the ws.
  - Sleep a while


Communications between the Scheduler and the ws
  - Has anything changed? In the beginning, just answer yes.
  - Get list of active jobs
  - For each job
      - id
      - timing info
      - job-specific parameters
  - Update status of a job
      - Status: running or waiting
      - Result: ok or error message
      - Progress (percentage?)
      - Next-time-to-run


Communications between the harvester and scheduler
  - Since these are in the same process, we don't need fnacy xml protocols.
    The harvester job can have an object that contains its status information
    (and a lock semaphore or something). It can update it when it feels like,
    and the scheduler can read this when it wants.
  - Constructor call
      - job-specific parameters
      - Storage handler, it will use for storing the results
      - an ID (or something) the harvester can use to find its stored state, if any
  - Harvest method
      - runs as long as it wants
      - reutrns one of
          - Finished OK
          - Please restart me in some time
          - Error message
          - Terminated as per instructions
  - Progress info
      - Percentage
      - Possibly some info on how many recoverable errors happend.


What next
  - Make a listener that runs under glassfish (will morph into the
    main scheduler)
  - define an abstract interface to a harvesterinstance
  - See how to talk to Jakub's ws. Get a list of jobs to do
  - Parse cron-like strings against current time and decide when to start
    (nice pure java exercise). In its own class?
  - Main loop through the task list
  - create dummy harvesting threads that return dummy results after some time
  - More details on the interfaces to both directions
  - Get more understanding of how the class structure should be

Classes needed
  - harverster itself 
    - implements runnable
    - Make an abstract one
  - StorageManager, parameter for harvester that specifies where to put stuff
  - Scheduler (main class)
  - HarversterInstance (item in my main table). Can have an active harverster
    class, or not. Knows when it should be running. Private to Scheduler?
  - What ever needed for using the ws (ask Jakub)
  - CronLine. Keeps a cron line, and answers the question if it should be run.
    Knows when last run, as well. Private to Scheduler?








